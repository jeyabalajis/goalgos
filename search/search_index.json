{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Go Algos A curated set of algorithms that exploit the power and simplicity of golang Wherever possible, the problem at hand is broken down to sub problems and solved through recursion combined together with parallelism. Build Status : Go Report Card :","title":"Home"},{"location":"#go-algos","text":"A curated set of algorithms that exploit the power and simplicity of golang Wherever possible, the problem at hand is broken down to sub problems and solved through recursion combined together with parallelism. Build Status : Go Report Card :","title":"Go Algos"},{"location":"graph/tree/max-sum-possible-tree/","text":"Maximum Sum Possible in a Tree Problem Statement: Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Leet Code Link Solution Fundamentally, this is a tree traversal algorithm. The following are the facts provided already: A path must pass through a node. A path need not have to go through root node for it to be considered. This means that the maximum could either be a single node on it's own (or) it could be a small sub-tree contained within a node and it can be at level level of the tree. The entire tree must be traversed before we can arrive at a deterministic answer. To solve this, Each node must be treated as a first class citizen on it's own. I.e. Keep a Hash at a particular node level. The algorithm must keep track of traversal from each node along it's children. Whenever a new node is encountered, a new hash is formed and any children traversals are accumulated at this hash level Once the problem is broken as above, the solution is pretty easy. Against each node (hash), keep track of the maximum sum on the left traversal and right traversal separately The total sum for a hash (i.e. at a node level) would be the node's value + left maximum + right maximum. Every node traversal (including root) will result in two go routines: one go routine that's a continuation of it's parent one go routine with this node as a first class citizen The accumulated value uptil all the iterations for a Hash shall be passed as a parameter to the recursive function Hash Map updates ( left maximum and right maximum ) will happen only when the current accumulated value is greater than what is already available . For the diagram illustrated above, the Hash data structure would look as follows: { \"0-6-ROOT\": { \"left_max\": 6, \"right_max\": 16 }, \"1-4-LEFT\": { \"left_max\": -5, \"right_max\": 2 }, \"1-3-RIGHT\": { \"left_max\": 1, \"right_max\": 13 }, \"2--5-LEFT\": { \"left_max\": 0, \"right_max\": 0 }, \"2-2-RIGHT\": { \"left_max\": 0, \"right_max\": 0 }, \"2-1-LEFT\": { \"left_max\": 0, \"right_max\": 0 }, \"2-13-RIGHT\": { \"left_max\": 0, \"right_max\": 0 } } The maximum sum out of all these Hash Maps is against the root node and the value is 28. The core logic is as follows: // traverse each node and build up hash map by each node func traverse( t *tree.Tree, hm *TreePath, depth int, nodeQualifier string, hashKey string, acc int ) { if t == nil { wg.Done() return } if nodeQualifier == \"ROOT\" { hashKey = strconv.Itoa(depth) + \"-\" + strconv.Itoa(t.Value) + \"-\" + nodeQualifier hm.createHash(hashKey, t.Value) } else { var left bool = false if nodeQualifier == \"LEFT\" { left = true } hm.putHashValue(hashKey, left, acc+t.Value) } var _nodeQualifier = nodeQualifier var _acc = 0 if t.Left != nil { // if it is root, qualify as left or right, else, pass on the qualifier if nodeQualifier == \"ROOT\" { _nodeQualifier = \"LEFT\" } else { _acc = acc + t.Value } wg.Add(1) go traverse(t.Left, hm, depth+1, _nodeQualifier, hashKey, _acc) wg.Add(1) go traverse(t.Left, hm, depth+1, \"ROOT\", \"\", 0) } if t.Right != nil { // if it is root, qualify as left or right, else, pass on the qualifier if nodeQualifier == \"ROOT\" { _nodeQualifier = \"RIGHT\" } else { _acc = acc + t.Value } wg.Add(1) go traverse(t.Right, hm, depth+1, _nodeQualifier, hashKey, _acc) wg.Add(1) go traverse(t.Right, hm, depth+1, \"ROOT\", \"\", 0) } wg.Done() }","title":"Maximum sum possible in a tree"},{"location":"graph/tree/max-sum-possible-tree/#maximum-sum-possible-in-a-tree","text":"","title":"Maximum Sum Possible in a Tree"},{"location":"graph/tree/max-sum-possible-tree/#problem-statement","text":"Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Leet Code Link","title":"Problem Statement:"},{"location":"graph/tree/max-sum-possible-tree/#solution","text":"Fundamentally, this is a tree traversal algorithm. The following are the facts provided already: A path must pass through a node. A path need not have to go through root node for it to be considered. This means that the maximum could either be a single node on it's own (or) it could be a small sub-tree contained within a node and it can be at level level of the tree. The entire tree must be traversed before we can arrive at a deterministic answer. To solve this, Each node must be treated as a first class citizen on it's own. I.e. Keep a Hash at a particular node level. The algorithm must keep track of traversal from each node along it's children. Whenever a new node is encountered, a new hash is formed and any children traversals are accumulated at this hash level Once the problem is broken as above, the solution is pretty easy. Against each node (hash), keep track of the maximum sum on the left traversal and right traversal separately The total sum for a hash (i.e. at a node level) would be the node's value + left maximum + right maximum. Every node traversal (including root) will result in two go routines: one go routine that's a continuation of it's parent one go routine with this node as a first class citizen The accumulated value uptil all the iterations for a Hash shall be passed as a parameter to the recursive function Hash Map updates ( left maximum and right maximum ) will happen only when the current accumulated value is greater than what is already available . For the diagram illustrated above, the Hash data structure would look as follows: { \"0-6-ROOT\": { \"left_max\": 6, \"right_max\": 16 }, \"1-4-LEFT\": { \"left_max\": -5, \"right_max\": 2 }, \"1-3-RIGHT\": { \"left_max\": 1, \"right_max\": 13 }, \"2--5-LEFT\": { \"left_max\": 0, \"right_max\": 0 }, \"2-2-RIGHT\": { \"left_max\": 0, \"right_max\": 0 }, \"2-1-LEFT\": { \"left_max\": 0, \"right_max\": 0 }, \"2-13-RIGHT\": { \"left_max\": 0, \"right_max\": 0 } } The maximum sum out of all these Hash Maps is against the root node and the value is 28. The core logic is as follows: // traverse each node and build up hash map by each node func traverse( t *tree.Tree, hm *TreePath, depth int, nodeQualifier string, hashKey string, acc int ) { if t == nil { wg.Done() return } if nodeQualifier == \"ROOT\" { hashKey = strconv.Itoa(depth) + \"-\" + strconv.Itoa(t.Value) + \"-\" + nodeQualifier hm.createHash(hashKey, t.Value) } else { var left bool = false if nodeQualifier == \"LEFT\" { left = true } hm.putHashValue(hashKey, left, acc+t.Value) } var _nodeQualifier = nodeQualifier var _acc = 0 if t.Left != nil { // if it is root, qualify as left or right, else, pass on the qualifier if nodeQualifier == \"ROOT\" { _nodeQualifier = \"LEFT\" } else { _acc = acc + t.Value } wg.Add(1) go traverse(t.Left, hm, depth+1, _nodeQualifier, hashKey, _acc) wg.Add(1) go traverse(t.Left, hm, depth+1, \"ROOT\", \"\", 0) } if t.Right != nil { // if it is root, qualify as left or right, else, pass on the qualifier if nodeQualifier == \"ROOT\" { _nodeQualifier = \"RIGHT\" } else { _acc = acc + t.Value } wg.Add(1) go traverse(t.Right, hm, depth+1, _nodeQualifier, hashKey, _acc) wg.Add(1) go traverse(t.Right, hm, depth+1, \"ROOT\", \"\", 0) } wg.Done() }","title":"Solution"},{"location":"graph/tree/same-tree/","text":"Same Tree","title":"Same Tree"},{"location":"graph/tree/same-tree/#same-tree","text":"","title":"Same Tree"},{"location":"optimization/network/cheapest-flights-within-k-stops/","text":"Cheapest flights within k stops Problem Link This is a node traversal problem which can be attacked with recursion and parallelism. Keep a common variable for the cheapest cost Traverse nodes recursively and accumulate cost. For each traversal, validate whether the destination is reached and if yes, push to cheapest cost store The cheapest cost store shall accept the path & the cost only if the incoming cost is cheaper than the existing Once all the go routines complete, return the cheapest cost and the path","title":"Cheapest flights within k stops"},{"location":"optimization/network/cheapest-flights-within-k-stops/#cheapest-flights-within-k-stops","text":"Problem Link This is a node traversal problem which can be attacked with recursion and parallelism. Keep a common variable for the cheapest cost Traverse nodes recursively and accumulate cost. For each traversal, validate whether the destination is reached and if yes, push to cheapest cost store The cheapest cost store shall accept the path & the cost only if the incoming cost is cheaper than the existing Once all the go routines complete, return the cheapest cost and the path","title":"Cheapest flights within k stops"},{"location":"optimization/scheduling/schedule-courses/","text":"Schedule Courses","title":"Schedule Courses"},{"location":"optimization/scheduling/schedule-courses/#schedule-courses","text":"","title":"Schedule Courses"},{"location":"string/word-break/break-sentence-by-substr/","text":"Break Sentence by a Sub String","title":"Break Sentence by Sub String"},{"location":"string/word-break/break-sentence-by-substr/#break-sentence-by-a-sub-string","text":"","title":"Break Sentence by a Sub String"}]}