{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Go Algos A curated set of algorithms that exploit the power and simplicity of golang Wherever possible, the problem at hand is broken down to sub problems and solved through recursion combined together with parallelism. For advanced Graph Problems, Depth First Search has been utilized (where applicable) Build Status : Go Report Card :","title":"Home"},{"location":"#go-algos","text":"A curated set of algorithms that exploit the power and simplicity of golang Wherever possible, the problem at hand is broken down to sub problems and solved through recursion combined together with parallelism. For advanced Graph Problems, Depth First Search has been utilized (where applicable) Build Status : Go Report Card :","title":"Go Algos"},{"location":"graph/max-sum-possible-tree/","text":"Maximum Sum Possible in a Tree Problem Statement: Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example: Difficulty: Leet Code Link Solution TLDR; Treat each node as an independent tree on it's own and compute max path sum per node. The max of all such sums yields the result. Fundamentally, this is a tree traversal problem. The following are the facts provided in the problem statement: A path must pass through a node. A path need not have to go through root node for it to be considered. This means that the maximum sum path could either be a single node on it's own (or) it could be a small sub-tree contained within a node (and) it can be at level level of the tree. To solve this, Each node must be treated as a first class citizen on it's own. I.e. Keep a Hash at a particular node level. Whenever a new node is encountered, a new hash is formed and any children traversals are accumulated at this hash level The algorithm must keep track of traversal from each node along it's children; left and right separately. Once the problem is broken down as above, the solution is pretty easy. Against each node (hash), keep track of the maximum sum on the left traversal and right traversal separately. The total sum for a hash (i.e. against a node) would be the node's value + left maximum + right maximum. Every new node traversal (including root) will result in two go routines: one go routine that's a continuation of it's parent one go routine with this node as a first class citizen for the traversals below this node. The accumulated value uptil all the iterations for a Hash shall be passed as a parameter to the recursive function Hash Map updates ( left maximum and right maximum ) will happen only when the current accumulated value is greater than what is already available . For the diagram illustrated above, the Hash data structure would look as follows: { \"0-6-ROOT\": { \"left_max\": 6, \"right_max\": 16 }, \"1-4-ROOT\": { \"left_max\": -5, \"right_max\": 2 }, \"1-3-ROOT\": { \"left_max\": 1, \"right_max\": 13 }, \"2--5-ROOT\": { \"left_max\": 0, \"right_max\": 0 }, \"2-2-ROOT\": { \"left_max\": 0, \"right_max\": 0 }, \"2-1-ROOT\": { \"left_max\": 0, \"right_max\": 0 }, \"2-13-ROOT\": { \"left_max\": 0, \"right_max\": 0 } } The maximum sum out of all these Hash Maps is the maximum sum path. For the example mentioned above, this is against the root node and the value is 28. The core logic is as follows: // traverse each node and build up hash map by each node func traverse( t *tree.Tree, hm *TreePath, depth int, nodeQualifier string, hashKey string, acc int ) { if t == nil { wg.Done() return } if nodeQualifier == \"ROOT\" { hashKey = strconv.Itoa(depth) + \"-\" + strconv.Itoa(t.Value) + \"-\" + nodeQualifier hm.createHash(hashKey, t.Value) } else { var left bool = false if nodeQualifier == \"LEFT\" { left = true } hm.putHashValue(hashKey, left, acc+t.Value) } var _nodeQualifier = nodeQualifier var _acc = 0 if t.Left != nil { // if it is root, qualify as left or right, else, pass on the qualifier if nodeQualifier == \"ROOT\" { _nodeQualifier = \"LEFT\" } else { _acc = acc + t.Value } wg.Add(1) go traverse(t.Left, hm, depth+1, _nodeQualifier, hashKey, _acc) wg.Add(1) go traverse(t.Left, hm, depth+1, \"ROOT\", \"\", 0) } if t.Right != nil { // if it is root, qualify as left or right, else, pass on the qualifier if nodeQualifier == \"ROOT\" { _nodeQualifier = \"RIGHT\" } else { _acc = acc + t.Value } wg.Add(1) go traverse(t.Right, hm, depth+1, _nodeQualifier, hashKey, _acc) wg.Add(1) go traverse(t.Right, hm, depth+1, \"ROOT\", \"\", 0) } wg.Done() }","title":"Maximum sum possible in a tree"},{"location":"graph/max-sum-possible-tree/#maximum-sum-possible-in-a-tree","text":"","title":"Maximum Sum Possible in a Tree"},{"location":"graph/max-sum-possible-tree/#problem-statement","text":"Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.","title":"Problem Statement:"},{"location":"graph/max-sum-possible-tree/#example","text":"Difficulty: Leet Code Link","title":"Example:"},{"location":"graph/max-sum-possible-tree/#solution","text":"TLDR; Treat each node as an independent tree on it's own and compute max path sum per node. The max of all such sums yields the result. Fundamentally, this is a tree traversal problem. The following are the facts provided in the problem statement: A path must pass through a node. A path need not have to go through root node for it to be considered. This means that the maximum sum path could either be a single node on it's own (or) it could be a small sub-tree contained within a node (and) it can be at level level of the tree. To solve this, Each node must be treated as a first class citizen on it's own. I.e. Keep a Hash at a particular node level. Whenever a new node is encountered, a new hash is formed and any children traversals are accumulated at this hash level The algorithm must keep track of traversal from each node along it's children; left and right separately. Once the problem is broken down as above, the solution is pretty easy. Against each node (hash), keep track of the maximum sum on the left traversal and right traversal separately. The total sum for a hash (i.e. against a node) would be the node's value + left maximum + right maximum. Every new node traversal (including root) will result in two go routines: one go routine that's a continuation of it's parent one go routine with this node as a first class citizen for the traversals below this node. The accumulated value uptil all the iterations for a Hash shall be passed as a parameter to the recursive function Hash Map updates ( left maximum and right maximum ) will happen only when the current accumulated value is greater than what is already available . For the diagram illustrated above, the Hash data structure would look as follows: { \"0-6-ROOT\": { \"left_max\": 6, \"right_max\": 16 }, \"1-4-ROOT\": { \"left_max\": -5, \"right_max\": 2 }, \"1-3-ROOT\": { \"left_max\": 1, \"right_max\": 13 }, \"2--5-ROOT\": { \"left_max\": 0, \"right_max\": 0 }, \"2-2-ROOT\": { \"left_max\": 0, \"right_max\": 0 }, \"2-1-ROOT\": { \"left_max\": 0, \"right_max\": 0 }, \"2-13-ROOT\": { \"left_max\": 0, \"right_max\": 0 } } The maximum sum out of all these Hash Maps is the maximum sum path. For the example mentioned above, this is against the root node and the value is 28. The core logic is as follows: // traverse each node and build up hash map by each node func traverse( t *tree.Tree, hm *TreePath, depth int, nodeQualifier string, hashKey string, acc int ) { if t == nil { wg.Done() return } if nodeQualifier == \"ROOT\" { hashKey = strconv.Itoa(depth) + \"-\" + strconv.Itoa(t.Value) + \"-\" + nodeQualifier hm.createHash(hashKey, t.Value) } else { var left bool = false if nodeQualifier == \"LEFT\" { left = true } hm.putHashValue(hashKey, left, acc+t.Value) } var _nodeQualifier = nodeQualifier var _acc = 0 if t.Left != nil { // if it is root, qualify as left or right, else, pass on the qualifier if nodeQualifier == \"ROOT\" { _nodeQualifier = \"LEFT\" } else { _acc = acc + t.Value } wg.Add(1) go traverse(t.Left, hm, depth+1, _nodeQualifier, hashKey, _acc) wg.Add(1) go traverse(t.Left, hm, depth+1, \"ROOT\", \"\", 0) } if t.Right != nil { // if it is root, qualify as left or right, else, pass on the qualifier if nodeQualifier == \"ROOT\" { _nodeQualifier = \"RIGHT\" } else { _acc = acc + t.Value } wg.Add(1) go traverse(t.Right, hm, depth+1, _nodeQualifier, hashKey, _acc) wg.Add(1) go traverse(t.Right, hm, depth+1, \"ROOT\", \"\", 0) } wg.Done() }","title":"Solution"},{"location":"graph/same-tree/","text":"Same Tree Problem Statement: Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example: Difficulty: Leet Code Link Solution: This is a simple tree traversal problem. If we simply get a hash out of the node values, we will miss out on the structure of the tree. To solve this problem, we need a way to get a hash value of a tree that respects tree's structure. To incorporate a tree's structure also into it's hash, we can implement the following approach: For a node, include node's depth, it's qualifer ( ROOT , LEFT or RIGHT ) and it's value together and get a hash value. The sum of this hash value across all nodes is the hash value of a tree. Algorithm: Implement each node traversal as a go routine. At each node, compute Hash Value as a combination of it's depth, qualifier (left, right or root) and it's value. Collect all such hash values for the tree and compare the same with that of the other tree","title":"Same Tree"},{"location":"graph/same-tree/#same-tree","text":"","title":"Same Tree"},{"location":"graph/same-tree/#problem-statement","text":"Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value.","title":"Problem Statement:"},{"location":"graph/same-tree/#example","text":"Difficulty: Leet Code Link","title":"Example:"},{"location":"graph/same-tree/#solution","text":"This is a simple tree traversal problem. If we simply get a hash out of the node values, we will miss out on the structure of the tree. To solve this problem, we need a way to get a hash value of a tree that respects tree's structure. To incorporate a tree's structure also into it's hash, we can implement the following approach: For a node, include node's depth, it's qualifer ( ROOT , LEFT or RIGHT ) and it's value together and get a hash value. The sum of this hash value across all nodes is the hash value of a tree.","title":"Solution:"},{"location":"graph/same-tree/#algorithm","text":"Implement each node traversal as a go routine. At each node, compute Hash Value as a combination of it's depth, qualifier (left, right or root) and it's value. Collect all such hash values for the tree and compare the same with that of the other tree","title":"Algorithm:"},{"location":"optimization/cheapest-flights-within-k-stops/","text":"Cheapest flights within k stops Problem Link Solution This is a node traversal problem. This can be solved in two ways: This can be a depth first search (DFS) and can be attacked with recursion and parallelism. This can be a breadth first search. In this case, a Hash Map is maintained as follows: Against each node, the shortest distance from source & the previous node to this path is maintained Depth First Search Keep a common variable for the cheapest cost Traverse nodes recursively and accumulate cost. For each traversal, validate whether the destination is reached and if yes, push to cheapest cost store The cheapest cost store shall accept the path & the cost only if the incoming cost is cheaper than the existing Once all the go routines complete, return the cheapest cost and the path Source Code func searchGraphDfs(graph Node, src int, dest int, maxStops int, stops int, currCost int) (minCost int) { minCost = 99999 for _, edge := range graph.Children { var cost int if edge.Node.Value == dest && stops <= maxStops { cost = currCost + edge.Cost } else { cost = searchGraphDfs(edge.Node, src, dest, maxStops, stops+1, currCost+edge.Cost) } if cost < minCost { minCost = cost } } return minCost }","title":"Cheapest flights within k stops"},{"location":"optimization/cheapest-flights-within-k-stops/#cheapest-flights-within-k-stops","text":"Problem Link","title":"Cheapest flights within k stops"},{"location":"optimization/cheapest-flights-within-k-stops/#solution","text":"This is a node traversal problem. This can be solved in two ways: This can be a depth first search (DFS) and can be attacked with recursion and parallelism. This can be a breadth first search. In this case, a Hash Map is maintained as follows: Against each node, the shortest distance from source & the previous node to this path is maintained","title":"Solution"},{"location":"optimization/cheapest-flights-within-k-stops/#depth-first-search","text":"Keep a common variable for the cheapest cost Traverse nodes recursively and accumulate cost. For each traversal, validate whether the destination is reached and if yes, push to cheapest cost store The cheapest cost store shall accept the path & the cost only if the incoming cost is cheaper than the existing Once all the go routines complete, return the cheapest cost and the path","title":"Depth First Search"},{"location":"optimization/cheapest-flights-within-k-stops/#source-code","text":"func searchGraphDfs(graph Node, src int, dest int, maxStops int, stops int, currCost int) (minCost int) { minCost = 99999 for _, edge := range graph.Children { var cost int if edge.Node.Value == dest && stops <= maxStops { cost = currCost + edge.Cost } else { cost = searchGraphDfs(edge.Node, src, dest, maxStops, stops+1, currCost+edge.Cost) } if cost < minCost { minCost = cost } } return minCost }","title":"Source Code"},{"location":"optimization/schedule-courses/","text":"Schedule Courses Problem Statement There are n different online courses numbered from 1 to n. Each course has some duration(course length) t and closed on dth day. A course should be taken continuously for t days and must be finished before or on the dth day. You will start at the 1st day. Given n online courses represented by pairs (t,d), your task is to find the maximal number of courses that can be taken. Example: Input: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]] Output: 3 Explanation: There're totally 4 courses, but you can take 3 courses at most: First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day. Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date. Difficulty: Leet Code Link Solution The key concept behind attacking this problem is this: It is always profitable to take the course with a smaller end day prior to a course with a larger end day. This is because, the course with a smaller duration, if can be taken, can surely be taken only if it is taken prior to a course with a larger end day. So, the first thing we do is to order courses by their end day in ascending order . Secondly, when we try to fit in the courses, if we encounter a course that does not fit, we can try to swap out this course with the previous one (already put into the schedule), provided the current course duration is lesser than the one we are trying to swap out. For us to be able to do this, the courses being scheduled must be stored in a Max Heap (by Duration) for an easy swap. Source Code func ScheduleItems(items []ExternalItem) []ScheduledItem { // First sort the items to be scheduled in ascending order of end duration sort.Sort(ByEndingTime(items)) // Now go through the courses and put them into (Max) Heap. // If a course cannot fit, see if it can by popping the max item from the heap pq := &PriorityQueue{} heap.Init(pq) var start = 0 for _, item := range items { var internalItem = Item{value: item.Value, priority: item.Duration, start: start} if start+item.Duration <= item.EndingTime { internalItem.end = start + item.Duration heap.Push(pq, &internalItem) start = internalItem.end + 1 } else { maxHeapTop, _ := heap.Pop(pq).(*Item) if maxHeapTop.priority > item.Duration && maxHeapTop.start+item.Duration <= item.EndingTime { internalItem.start = maxHeapTop.start internalItem.end = maxHeapTop.start + item.Duration heap.Push(pq, &internalItem) start = internalItem.end + 1 } else { heap.Push(pq, &maxHeapTop) } } } var scheduledItems []ScheduledItem for pq.Len() > 0 { item := heap.Pop(pq).(*Item) scheduledItems = append( scheduledItems, ScheduledItem{Value: item.value, Start: item.start, Duration: item.priority, End: item.end}, ) } sort.Sort(ByEndTime(scheduledItems)) return scheduledItems }","title":"Schedule Courses"},{"location":"optimization/schedule-courses/#schedule-courses","text":"","title":"Schedule Courses"},{"location":"optimization/schedule-courses/#problem-statement","text":"There are n different online courses numbered from 1 to n. Each course has some duration(course length) t and closed on dth day. A course should be taken continuously for t days and must be finished before or on the dth day. You will start at the 1st day. Given n online courses represented by pairs (t,d), your task is to find the maximal number of courses that can be taken.","title":"Problem Statement"},{"location":"optimization/schedule-courses/#example","text":"Input: [[100, 200], [200, 1300], [1000, 1250], [2000, 3200]] Output: 3 Explanation: There're totally 4 courses, but you can take 3 courses at most: First, take the 1st course, it costs 100 days so you will finish it on the 100th day, and ready to take the next course on the 101st day. Second, take the 3rd course, it costs 1000 days so you will finish it on the 1100th day, and ready to take the next course on the 1101st day. Third, take the 2nd course, it costs 200 days so you will finish it on the 1300th day. The 4th course cannot be taken now, since you will finish it on the 3300th day, which exceeds the closed date. Difficulty: Leet Code Link","title":"Example:"},{"location":"optimization/schedule-courses/#solution","text":"The key concept behind attacking this problem is this: It is always profitable to take the course with a smaller end day prior to a course with a larger end day. This is because, the course with a smaller duration, if can be taken, can surely be taken only if it is taken prior to a course with a larger end day. So, the first thing we do is to order courses by their end day in ascending order . Secondly, when we try to fit in the courses, if we encounter a course that does not fit, we can try to swap out this course with the previous one (already put into the schedule), provided the current course duration is lesser than the one we are trying to swap out. For us to be able to do this, the courses being scheduled must be stored in a Max Heap (by Duration) for an easy swap.","title":"Solution"},{"location":"optimization/schedule-courses/#source-code","text":"func ScheduleItems(items []ExternalItem) []ScheduledItem { // First sort the items to be scheduled in ascending order of end duration sort.Sort(ByEndingTime(items)) // Now go through the courses and put them into (Max) Heap. // If a course cannot fit, see if it can by popping the max item from the heap pq := &PriorityQueue{} heap.Init(pq) var start = 0 for _, item := range items { var internalItem = Item{value: item.Value, priority: item.Duration, start: start} if start+item.Duration <= item.EndingTime { internalItem.end = start + item.Duration heap.Push(pq, &internalItem) start = internalItem.end + 1 } else { maxHeapTop, _ := heap.Pop(pq).(*Item) if maxHeapTop.priority > item.Duration && maxHeapTop.start+item.Duration <= item.EndingTime { internalItem.start = maxHeapTop.start internalItem.end = maxHeapTop.start + item.Duration heap.Push(pq, &internalItem) start = internalItem.end + 1 } else { heap.Push(pq, &maxHeapTop) } } } var scheduledItems []ScheduledItem for pq.Len() > 0 { item := heap.Pop(pq).(*Item) scheduledItems = append( scheduledItems, ScheduledItem{Value: item.value, Start: item.start, Duration: item.priority, End: item.end}, ) } sort.Sort(ByEndTime(scheduledItems)) return scheduledItems }","title":"Source Code"},{"location":"string/word-break/break-sentence-by-substr/","text":"Break Sentence by a Sub String","title":"Break Sentence by a Sub String"},{"location":"string/word-break/break-sentence-by-substr/#break-sentence-by-a-sub-string","text":"","title":"Break Sentence by a Sub String"}]}