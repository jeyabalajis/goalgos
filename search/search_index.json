{"config":{"lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Go Algos A curated set of algorithms that exploit the power and simplicity of golang Wherever possible, the problem at hand is broken down to sub problems and solved through recursion combined together with parallelism. Build Status : Go Report Card :","title":"Home"},{"location":"#go-algos","text":"A curated set of algorithms that exploit the power and simplicity of golang Wherever possible, the problem at hand is broken down to sub problems and solved through recursion combined together with parallelism. Build Status : Go Report Card :","title":"Go Algos"},{"location":"graph/max-sum-possible-tree/","text":"Maximum Sum Possible in a Tree Problem Statement: Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root. Example: Difficulty: Leet Code Link Solution TLDR; Treat each node as an independent tree on it's own and compute max path sum per node. The max of all such sums yields the result. Fundamentally, this is a tree traversal problem. The following are the facts provided in the problem statement: A path must pass through a node. A path need not have to go through root node for it to be considered. This means that the maximum sum path could either be a single node on it's own (or) it could be a small sub-tree contained within a node (and) it can be at level level of the tree. To solve this, Each node must be treated as a first class citizen on it's own. I.e. Keep a Hash at a particular node level. Whenever a new node is encountered, a new hash is formed and any children traversals are accumulated at this hash level The algorithm must keep track of traversal from each node along it's children; left and right separately. Once the problem is broken down as above, the solution is pretty easy. Against each node (hash), keep track of the maximum sum on the left traversal and right traversal separately. The total sum for a hash (i.e. against a node) would be the node's value + left maximum + right maximum. Every new node traversal (including root) will result in two go routines: one go routine that's a continuation of it's parent one go routine with this node as a first class citizen for the traversals below this node. The accumulated value uptil all the iterations for a Hash shall be passed as a parameter to the recursive function Hash Map updates ( left maximum and right maximum ) will happen only when the current accumulated value is greater than what is already available . For the diagram illustrated above, the Hash data structure would look as follows: { \"0-6-ROOT\": { \"left_max\": 6, \"right_max\": 16 }, \"1-4-ROOT\": { \"left_max\": -5, \"right_max\": 2 }, \"1-3-ROOT\": { \"left_max\": 1, \"right_max\": 13 }, \"2--5-ROOT\": { \"left_max\": 0, \"right_max\": 0 }, \"2-2-ROOT\": { \"left_max\": 0, \"right_max\": 0 }, \"2-1-ROOT\": { \"left_max\": 0, \"right_max\": 0 }, \"2-13-ROOT\": { \"left_max\": 0, \"right_max\": 0 } } The maximum sum out of all these Hash Maps is the maximum sum path. For the example mentioned above, this is against the root node and the value is 28. The core logic is as follows: // traverse each node and build up hash map by each node func traverse( t *tree.Tree, hm *TreePath, depth int, nodeQualifier string, hashKey string, acc int ) { if t == nil { wg.Done() return } if nodeQualifier == \"ROOT\" { hashKey = strconv.Itoa(depth) + \"-\" + strconv.Itoa(t.Value) + \"-\" + nodeQualifier hm.createHash(hashKey, t.Value) } else { var left bool = false if nodeQualifier == \"LEFT\" { left = true } hm.putHashValue(hashKey, left, acc+t.Value) } var _nodeQualifier = nodeQualifier var _acc = 0 if t.Left != nil { // if it is root, qualify as left or right, else, pass on the qualifier if nodeQualifier == \"ROOT\" { _nodeQualifier = \"LEFT\" } else { _acc = acc + t.Value } wg.Add(1) go traverse(t.Left, hm, depth+1, _nodeQualifier, hashKey, _acc) wg.Add(1) go traverse(t.Left, hm, depth+1, \"ROOT\", \"\", 0) } if t.Right != nil { // if it is root, qualify as left or right, else, pass on the qualifier if nodeQualifier == \"ROOT\" { _nodeQualifier = \"RIGHT\" } else { _acc = acc + t.Value } wg.Add(1) go traverse(t.Right, hm, depth+1, _nodeQualifier, hashKey, _acc) wg.Add(1) go traverse(t.Right, hm, depth+1, \"ROOT\", \"\", 0) } wg.Done() }","title":"Maximum sum possible in a tree"},{"location":"graph/max-sum-possible-tree/#maximum-sum-possible-in-a-tree","text":"","title":"Maximum Sum Possible in a Tree"},{"location":"graph/max-sum-possible-tree/#problem-statement","text":"Given a non-empty binary tree, find the maximum path sum. For this problem, a path is defined as any sequence of nodes from some starting node to any node in the tree along the parent-child connections. The path must contain at least one node and does not need to go through the root.","title":"Problem Statement:"},{"location":"graph/max-sum-possible-tree/#example","text":"Difficulty: Leet Code Link","title":"Example:"},{"location":"graph/max-sum-possible-tree/#solution","text":"TLDR; Treat each node as an independent tree on it's own and compute max path sum per node. The max of all such sums yields the result. Fundamentally, this is a tree traversal problem. The following are the facts provided in the problem statement: A path must pass through a node. A path need not have to go through root node for it to be considered. This means that the maximum sum path could either be a single node on it's own (or) it could be a small sub-tree contained within a node (and) it can be at level level of the tree. To solve this, Each node must be treated as a first class citizen on it's own. I.e. Keep a Hash at a particular node level. Whenever a new node is encountered, a new hash is formed and any children traversals are accumulated at this hash level The algorithm must keep track of traversal from each node along it's children; left and right separately. Once the problem is broken down as above, the solution is pretty easy. Against each node (hash), keep track of the maximum sum on the left traversal and right traversal separately. The total sum for a hash (i.e. against a node) would be the node's value + left maximum + right maximum. Every new node traversal (including root) will result in two go routines: one go routine that's a continuation of it's parent one go routine with this node as a first class citizen for the traversals below this node. The accumulated value uptil all the iterations for a Hash shall be passed as a parameter to the recursive function Hash Map updates ( left maximum and right maximum ) will happen only when the current accumulated value is greater than what is already available . For the diagram illustrated above, the Hash data structure would look as follows: { \"0-6-ROOT\": { \"left_max\": 6, \"right_max\": 16 }, \"1-4-ROOT\": { \"left_max\": -5, \"right_max\": 2 }, \"1-3-ROOT\": { \"left_max\": 1, \"right_max\": 13 }, \"2--5-ROOT\": { \"left_max\": 0, \"right_max\": 0 }, \"2-2-ROOT\": { \"left_max\": 0, \"right_max\": 0 }, \"2-1-ROOT\": { \"left_max\": 0, \"right_max\": 0 }, \"2-13-ROOT\": { \"left_max\": 0, \"right_max\": 0 } } The maximum sum out of all these Hash Maps is the maximum sum path. For the example mentioned above, this is against the root node and the value is 28. The core logic is as follows: // traverse each node and build up hash map by each node func traverse( t *tree.Tree, hm *TreePath, depth int, nodeQualifier string, hashKey string, acc int ) { if t == nil { wg.Done() return } if nodeQualifier == \"ROOT\" { hashKey = strconv.Itoa(depth) + \"-\" + strconv.Itoa(t.Value) + \"-\" + nodeQualifier hm.createHash(hashKey, t.Value) } else { var left bool = false if nodeQualifier == \"LEFT\" { left = true } hm.putHashValue(hashKey, left, acc+t.Value) } var _nodeQualifier = nodeQualifier var _acc = 0 if t.Left != nil { // if it is root, qualify as left or right, else, pass on the qualifier if nodeQualifier == \"ROOT\" { _nodeQualifier = \"LEFT\" } else { _acc = acc + t.Value } wg.Add(1) go traverse(t.Left, hm, depth+1, _nodeQualifier, hashKey, _acc) wg.Add(1) go traverse(t.Left, hm, depth+1, \"ROOT\", \"\", 0) } if t.Right != nil { // if it is root, qualify as left or right, else, pass on the qualifier if nodeQualifier == \"ROOT\" { _nodeQualifier = \"RIGHT\" } else { _acc = acc + t.Value } wg.Add(1) go traverse(t.Right, hm, depth+1, _nodeQualifier, hashKey, _acc) wg.Add(1) go traverse(t.Right, hm, depth+1, \"ROOT\", \"\", 0) } wg.Done() }","title":"Solution"},{"location":"graph/same-tree/","text":"Same Tree Problem Statement: Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value. Example: Difficulty: Leet Code Link Solution: This is a simple tree traversal problem. If we simply get a hash out of the node values, we will miss out on the structure of the tree. To solve this problem, we need a way to get a hash value of a tree that respects tree's structure. To incorporate a tree's structure also into it's hash, we can implement the following approach: For a node, include node's depth, it's qualifer ( ROOT , LEFT or RIGHT ) and it's value together and get a hash value. The sum of this hash value across all nodes is the hash value of a tree. Algorithm: Implement each node traversal as a go routine. At each node, compute Hash Value as a combination of it's depth, qualifier (left, right or root) and it's value. Collect all such hash values for the tree and compare the same with that of the other tree","title":"Same Tree"},{"location":"graph/same-tree/#same-tree","text":"","title":"Same Tree"},{"location":"graph/same-tree/#problem-statement","text":"Given two binary trees, write a function to check if they are the same or not. Two binary trees are considered the same if they are structurally identical and the nodes have the same value.","title":"Problem Statement:"},{"location":"graph/same-tree/#example","text":"Difficulty: Leet Code Link","title":"Example:"},{"location":"graph/same-tree/#solution","text":"This is a simple tree traversal problem. If we simply get a hash out of the node values, we will miss out on the structure of the tree. To solve this problem, we need a way to get a hash value of a tree that respects tree's structure. To incorporate a tree's structure also into it's hash, we can implement the following approach: For a node, include node's depth, it's qualifer ( ROOT , LEFT or RIGHT ) and it's value together and get a hash value. The sum of this hash value across all nodes is the hash value of a tree.","title":"Solution:"},{"location":"graph/same-tree/#algorithm","text":"Implement each node traversal as a go routine. At each node, compute Hash Value as a combination of it's depth, qualifier (left, right or root) and it's value. Collect all such hash values for the tree and compare the same with that of the other tree","title":"Algorithm:"},{"location":"optimization/cheapest-flights-within-k-stops/","text":"Cheapest flights within k stops Problem Link This is a node traversal problem which can be attacked with recursion and parallelism. Keep a common variable for the cheapest cost Traverse nodes recursively and accumulate cost. For each traversal, validate whether the destination is reached and if yes, push to cheapest cost store The cheapest cost store shall accept the path & the cost only if the incoming cost is cheaper than the existing Once all the go routines complete, return the cheapest cost and the path","title":"Cheapest flights within k stops"},{"location":"optimization/cheapest-flights-within-k-stops/#cheapest-flights-within-k-stops","text":"Problem Link This is a node traversal problem which can be attacked with recursion and parallelism. Keep a common variable for the cheapest cost Traverse nodes recursively and accumulate cost. For each traversal, validate whether the destination is reached and if yes, push to cheapest cost store The cheapest cost store shall accept the path & the cost only if the incoming cost is cheaper than the existing Once all the go routines complete, return the cheapest cost and the path","title":"Cheapest flights within k stops"},{"location":"optimization/schedule-courses/","text":"Schedule Courses","title":"Schedule Courses"},{"location":"optimization/schedule-courses/#schedule-courses","text":"","title":"Schedule Courses"},{"location":"string/word-break/break-sentence-by-substr/","text":"Break Sentence by a Sub String","title":"Break Sentence by a Sub String"},{"location":"string/word-break/break-sentence-by-substr/#break-sentence-by-a-sub-string","text":"","title":"Break Sentence by a Sub String"}]}